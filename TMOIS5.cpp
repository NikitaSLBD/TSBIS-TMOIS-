// Подключаем библиотеки
#include <vector>
#include <windows.h>
#include <utility>

using namespace std; // Задаём пространство имён

void main() // Главная функция
{
    // Задаём кодировку ввода и вывода для консоли
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);


    int m_A1, m_A2, m_A3, m_B1, m_B2, m_B3, par1, ord; // Декларация переменных

    printf("Введите мощность области отправления А1: "); // Вывод инструкции для пользователя
    scanf_s("%i", &m_A1); // Заносим ввод пользователя в переменную m_A 

    vector <int> A1(m_A1); // Декларация графика А размером m_A

    // Цикл для записи графика А
    for (int j1 = 0; j1 < m_A1; j1++)
    {
        printf("%s %i %s", "Введите ", j1 + 1, "элемент множества A1: "); // Вывод инструкции для пользователя
        scanf_s("%i", &A1[j1]); // Заносим ввод пользователя в переменную A[j]
    }

    printf("Введите мощность области прибытия А2: "); // Вывод инструкции для пользователя
    scanf_s("%i", &m_A2); // Заносим ввод пользователя в переменную m_A 

    vector <int> A2(m_A2); // Декларация графика А размером m_A

    // Цикл для записи графика А
    for (int j2 = 0; j2 < m_A2; j2++)
    {
        printf("%s %i %s", "Введите ", j2 + 1, "элемент множества A2: "); // Вывод инструкции для пользователя
        scanf_s("%i", &A2[j2]); // Заносим ввод пользователя в переменную A[j]
    }

    printf("Введите мощность области задания А3 : "); // Вывод инструкции для пользователя
    scanf_s("%i", &m_A3); // Заносим ввод пользователя в переменную m_B

    vector <pair <int, int> > A3(m_A3); // Декларация множества В размером m_B

    // Цикл для записи множества В
    for (int j3 = 0; j3 < m_A3; j3++)
    {
        printf("%s %i %s", "Введите ", j3 + 1, "кортеж графика А3: "); // Вывод инструкции для пользователя
        scanf_s("%i %i", &A3[j3].first, &A3[j3].second); // Заносим ввод пользователя в переменную B[i]
    }

    printf("Введите мощность области отправления B1: "); // Вывод инструкции для пользователя
    scanf_s("%i", &m_B1); // Заносим ввод пользователя в переменную m_A 

    vector <int> B1(m_B1); // Декларация графика А размером m_A

    // Цикл для записи графика А
    for (int i1 = 0; i1 < m_B1; i1++)
    {
        printf("%s %i %s", "Введите ", i1 + 1, "'элемент множества B1: "); // Вывод инструкции для пользователя
        scanf_s("%i", &B1[i1]); // Заносим ввод пользователя в переменную A[j]
    }

    printf("Введите мощность области прибытия B2: "); // Вывод инструкции для пользователя
    scanf_s("%i", &m_B2); // Заносим ввод пользователя в переменную m_A 

    vector <int> B2(m_B2); // Декларация графика А размером m_A

    // Цикл для записи графика А
    for (int i2 = 0; i2 < m_B2; i2++)
    {
        printf("%s %i %s", "Введите ", i2 + 1, "'элемент множества B2: "); // Вывод инструкции для пользователя
        scanf_s("%i", &B2[i2]); // Заносим ввод пользователя в переменную A[j]
    }

    printf("Введите мощность области задания B3 : "); // Вывод инструкции для пользователя
    scanf_s("%i", &m_B3); // Заносим ввод пользователя в переменную m_B

    vector <pair <int, int> > B3(m_B3); // Декларация множества В размером m_B

    // Цикл для записи множества В
    for (int i3 = 0; i3 < m_B3; i3++)
    {
        printf("%s %i %s", "Введите ", i3 + 1, "кортеж графика B3: "); // Вывод инструкции для пользователя
        scanf_s("%i %i", &B3[i3].first, &B3[i3].second); // Заносим ввод пользователя в переменную B[i]
    }

    vector <int> C;
    vector <int> C1; // Декларация графика С
    vector <int> C2; // Декларация графика С
    vector <pair <int, int> > C3; // Декларация графика С

    // Вывод меню операций и инструкции для пользователя
    printf("\nВыберите операцию (1, 2, 3, 4, 5, 6, 7, 8, 9, 10 или 11): ");
    printf("\n1) Объединение\n");
    printf("2) Пересечение\n");
    printf("3) Разность\n");
    printf("4) Симметрическая разность\n");
    printf("5) Дополнение\n");
    printf("6) Инверсия\n");
    printf("7) Композиция\n");
    printf("8) Продолжение\n");
    printf("9) Сужение\n");
    printf("10) Образ\n");
    printf("11) Прообраз\n");
    scanf_s("%i", &par1); // Заносим ввод пользователя в переменную

    // Проверка значения переменной 
    switch (par1)
    {
    case 1: // Операция объединения
    {

        // Цикл для записи графика А в график С
        for (int j1 = 0; j1 < m_A1; j1++)
        {
            C1.push_back(A1[j1]); // Запись всех элементов графика А в график С
        }

        // Вложенный цикл для обработки элементоd графиков В и А
        for (int i1 = 0; i1 < m_B1; i1++)
        {
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                if (B1[i1] != A1[j1] && j1 == m_A1 - 1) // Проверка на неравенство элементов графиков В и А, и на то, что элемент гафика А является последним 
                {
                    C1.push_back(B1[i1]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
                else
                {
                    if (B1[i1] == A1[j1]) // Проверка на равенство элементов графиков В и А
                        break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        for (int j2 = 0; j2 < m_A2; j2++)
        {
            C2.push_back(A2[j2]); // Запись всех элементов графика А в график С
        }

        // Вложенный цикл для обработки элементоd графиков В и А
        for (int i2 = 0; i2 < m_B2; i2++)
        {
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                if (B2[i2] != A2[j2] && j2 == m_A2 - 1) // Проверка на неравенство элементов графиков В и А, и на то, что элемент гафика А является последним 
                {
                    C2.push_back(B2[i2]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
                else
                {
                    if (B2[i2] == A2[j2]) // Проверка на равенство элементов графиков В и А
                        break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        for (int j3 = 0; j3 < m_A3; j3++)
        {
            C3.push_back(A3[j3]); // Запись всех элементов графика А в график С
        }

        // Вложенный цикл для обработки элементоd графиков В и А
        for (int i3 = 0; i3 < m_B3; i3++)
        {
            for (int j3 = 0; j3 < m_A3; j3++)
            {
                if (B3[i3] != A3[j3] && j3 == m_A3 - 1) // Проверка на неравенство элементов графиков В и А, и на то, что элемент гафика А является последним 
                {
                    C3.push_back(B3[i3]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
                else
                {
                    if (B3[i3] == A3[j3]) // Проверка на равенство элементов графиков В и А
                        break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        break; // Выходим из блока switch
    }

    case 2: // Операция пересечения
    {
        // Вложенный цикл для обработки элементов графиков В и А
        for (int j1 = 0; j1 < m_A1; j1++)
        {
            for (int i1 = 0; i1 < m_B1; i1++)
            {
                if (B1[i1] == A1[j1]) // Проверка на равенство элементов графиков В и А
                {
                    C1.push_back(B1[i1]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        // Вложенный цикл для обработки элементов графиков В и А
        for (int j2 = 0; j2 < m_A2; j2++)
        {
            for (int i2 = 0; i2 < m_B2; i2++)
            {
                if (B2[i2] == A2[j2]) // Проверка на равенство элементов графиков В и А
                {
                    C2.push_back(B2[i2]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        // Вложенный цикл для обработки элементов графиков В и А
        for (int j3 = 0; j3 < m_A3; j3++)
        {
            for (int i3 = 0; i3 < m_B3; i3++)
            {
                if (B3[i3] == A3[j3]) // Проверка на равенство элементов графиков В и А
                {
                    C3.push_back(B3[i3]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        break; // Выходим из блока switch
    }

    case 3: // Операция разности
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) А\\В");
        printf("\n2) В\\А\n");
        printf("Выберите порядок разности (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменную

        if (ord == 1) // Проверка переменной 
        {
            // Цикл для обработки элементов графика А
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                if (count(B1.begin(), B1.end(), A1[j1]) == 0) // Проверка наличия элементов графика А в В
                    C1.push_back(A1[j1]); // Записываем элемент графика А в С
            }

            // Цикл для обработки элементов графика А
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                if (count(B2.begin(), B2.end(), A2[j2]) == 0) // Проверка наличия элементов графика А в В
                    C2.push_back(A2[j2]); // Записываем элемент графика А в С
            }

            // Цикл для обработки элементов графика А
            for (int j3 = 0; j3 < m_A3; j3++)
            {
                if (count(B3.begin(), B3.end(), A3[j3]) == 0) // Проверка наличия элементов графика А в В
                    C3.push_back(A3[j3]); // Записываем элемент графика А в С
            }
        }
        else
        {
            // Цикл для обработки элементов графика А
            for (int i1 = 0; i1 < m_B1; i1++)
            {
                if (count(A1.begin(), A1.end(), B1[i1]) == 0) // Проверка наличия элементов графика А в В
                    C1.push_back(B1[i1]); // Записываем элемент графика А в С
            }

            // Цикл для обработки элементов графика А
            for (int i2 = 0; i2 < m_B2; i2++)
            {
                if (count(A2.begin(), A2.end(), B2[i2]) == 0) // Проверка наличия элементов графика А в В
                    C2.push_back(B2[i2]); // Записываем элемент графика А в С
            }

            // Цикл для обработки элементов графика А
            for (int i3 = 0; i3 < m_B3; i3++)
            {
                if (count(A3.begin(), A3.end(), B3[i3]) == 0) // Проверка наличия элементов графика А в В
                    C3.push_back(B3[i3]); // Записываем элемент графика А в С
            }
        }

        break; // Выходим из блока switch
    }

    case 4: // Операция симметрической разности
    {
        // Цикл для записи графика А в график С
        for (int j1 = 0; j1 < m_A1; j1++)
        {
            C1.push_back(A1[j1]); // Запись всех элементов графика А в график С
        }

        // Вложенный цикл для обработки элементоd графиков В и А
        for (int i1 = 0; i1 < m_B1; i1++)
        {
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                if (B1[i1] != A1[j1] && j1 == m_A1 - 1) // Проверка на неравенство элементов графиков В и А, и на то, что элемент гафика А является последним 
                {
                    C1.push_back(B1[i1]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
                else
                {
                    if (B1[i1] == A1[j1]) // Проверка на равенство элементов графиков В и А
                        break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        for (int j2 = 0; j2 < m_A2; j2++)
        {
            C2.push_back(A2[j2]); // Запись всех элементов графика А в график С
        }

        // Вложенный цикл для обработки элементоd графиков В и А
        for (int i2 = 0; i2 < m_B2; i2++)
        {
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                if (B2[i2] != A2[j2] && j2 == m_A2 - 1) // Проверка на неравенство элементов графиков В и А, и на то, что элемент гафика А является последним 
                {
                    C2.push_back(B2[i2]); // Записываем элемент графика В в график С
                    break; // Выходим из цикла и начинаем следующую итерацию i++
                }
                else
                {
                    if (B2[i2] == A2[j2]) // Проверка на равенство элементов графиков В и А
                        break; // Выходим из цикла и начинаем следующую итерацию i++
                }
            }
        }

        // Цикл для обработки элементов графика А
        for (int j3 = 0; j3 < m_A3; j3++)
        {
            if (count(B3.begin(), B3.end(), A3[j3]) == 0) // Проверка наличия элементов графика А в В
                C3.push_back(A3[j3]); // Записываем элемент графика А в С
        }

        // Цикл для обработки элементов графика А
        for (int i3 = 0; i3 < m_B3; i3++)
        {
            if (count(A3.begin(), A3.end(), B3[i3]) == 0) // Проверка наличия элементов графика А в В
                C3.push_back(B3[i3]); // Записываем элемент графика А в С
        }

        break; // Выходим из блока switch
    }

    case 5: // Операция дополнения 
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) А'");
        printf("\n2) В'\n");
        printf("Выберите график над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменную

        // Цикл для обработки элементов универсального множества
        for (int p = 1; p < 100; p++)
        {
            if (ord == 1) // Проверка переменной 
            {
                if (count(A1.begin(), A1.end(), p) == 0) // Проверка наличия элементов универсального множества в А
                    C1.push_back(p); // Записываем элемент универсального множества в С

                if (count(A2.begin(), A2.end(), p) == 0) // Проверка наличия элементов универсального множества в А
                    C2.push_back(p); // Записываем элемент универсального множества в С
            }
            else
            {
                if (count(B1.begin(), B1.end(), p) == 0) // Проверка наличия элементов универсального множества в В
                    C1.push_back(p); // Записываем элемент универсального множества в С

                if (count(B2.begin(), B2.end(), p) == 0) // Проверка наличия элементов универсального множества в В
                    C2.push_back(p); // Записываем элемент универсального множества в С
            }
        }


        vector <pair <int, int> > U(10000);
        int u = 0;

        // Цикл для создания универсального графика
        for (int p = 1; p <= 100; p++)
        {
            for (int q = 1; q <= 100; q++, u++)
            {
                U[u].first = p;
                U[u].second = q;
            }

        }

        // Цикл для обработки элементов универсального графика
        for (int p = 0; p < U.size(); p++)
        {
            if (ord == 1) // Проверка переменной 
            {
                if (count(A3.begin(), A3.end(), U[p]) == 0) // Проверка наличия элементов универсального графика в А
                    C3.push_back(U[p]); // Записываем элемент универсального графика в С
            }
            else
            {
                if (count(B3.begin(), B3.end(), U[p]) == 0) // Проверка наличия элементов универсального графика в В
                    C3.push_back(U[p]); // Записываем элемент универсального графика в С
            }
        }
        break; // Выходим из блока switch
    }

    case 6: // Операция инверсии
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) А^-1");
        printf("\n2) В^-1\n");
        printf("Выберите график над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменную

        


        if (ord == 1) // Проверка переменной 
        {
            // Цикл для записи графика А в график С
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                C1.push_back(A2[j2]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                C2.push_back(A1[j1]); // Запись всех элементов графика А в график С
            }


            for (int j3 = 0; j3 < m_A3; j3++) // Цикл для обработки элементов графика А
                C3.push_back(make_pair(A3[j3].second, A3[j3].first)); // Добавляем инверсированную пару А в С
        }
        else
        {
            // Цикл для записи графика А в график С
            for (int i2 = 0; i2 < m_B2; i2++)
            {
                C1.push_back(B2[i2]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int i1 = 0; i1 < m_A2; i1++)
            {
                C2.push_back(B1[i1]); // Запись всех элементов графика А в график С
            }


            for (int i3 = 0; i3 < m_B3; i3++) // Цикл для обработки элементов графика А
                C3.push_back(make_pair(B3[i3].second, B3[i3].first)); // Добавляем инверсированную пару А в С
        }

        break; // Выходим из блока switch
    }

    case 7: // Операция композиции
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) А*B");
        printf("\n2) B*A\n");
        printf("Выберите график над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменную

        if (ord == 1) // Проверка переменной
        {
            // Цикл для записи графика А в график С
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                C1.push_back(A1[j1]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int i2 = 0; i2 < m_B2; i2++)
            {
                C2.push_back(B2[i2]); // Запись всех элементов графика А в график С
            }

            for (int j3 = 0; j3 < m_A3; j3++) // Цикл для обработки элементов графика А
                for (int i3 = 0; i3 < m_B3; i3++) // Цикл для обработки элементов графика В
                    if (A3[j3].second == B3[i3].first && count(C3.begin(), C3.end(), make_pair(A3[j3].first, B3[i3].second)) == 0) // Проверка условий для композиции А и В
                        C3.push_back(make_pair(A3[j3].first, B3[i3].second)); // Добавляем пару, которая является результатом композиции А и В в С
        }
        else
        {
            // Цикл для записи графика А в график С
            for (int i1 = 0; i1 < m_B1; i1++)
            {
                C1.push_back(B1[i1]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                C2.push_back(A2[j2]); // Запись всех элементов графика А в график С
            }

            for (int i3 = 0; i3 < m_B3; i3++) // Цикл для обработки элементов графика В
                for (int j3 = 0; j3 < m_A3; j3++) // Цикл для обработки элементов графика А
                    if (B3[i3].second == A3[j3].first && count(C3.begin(), C3.end(), make_pair(B3[i3].first, A3[j3].second)) == 0) // Проверка условий для композиции В и А
                        C3.push_back(make_pair(B3[i3].first, A3[j3].second)); // Добавляем пару, которая является результатом композиции В и А в С
        }

        break; // Выходим из блока switch

    case 8:
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) Продолжение А");
        printf("\n2) Продолжение B\n");
        printf("Выберите соответствие над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменную

        if (ord == 1)
        {
            // Цикл для записи графика А в график С
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                C1.push_back(A1[j1]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                C2.push_back(A2[j2]); // Запись всех элементов графика А в график С
            }

            for (int i = 0; i < C1.size(); i++)
                for (int j = 0; j < C2.size(); j++)
                    if (count(C3.begin(), C3.end(), make_pair(C1[i], C2[j])) == 0)
                        C3.push_back(make_pair(C1[i], C2[j]));
        }
        else
        {
            // Цикл для записи графика А в график С
            for (int i1 = 0; i1 < m_B1; i1++)
            {
                C1.push_back(B1[i1]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int i2 = 0; i2 < m_B2; i2++)
            {
                C2.push_back(B2[i2]); // Запись всех элементов графика А в график С
            }

            for (int i = 0; i < C1.size(); i++)
                for (int j = 0; j < C2.size(); j++)
                    if (count(C3.begin(), C3.end(), make_pair(C1[i], C2[j])) == 0)
                        C3.push_back(make_pair(C1[i], C2[j]));
        }

        break;

    }

    case 9:
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) Сужение А");
        printf("\n2) Сужение B\n");
        printf("Выберите соответствие над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменну

        if (ord == 1)
        {
            // Цикл для записи графика А в график С
            for (int j1 = 0; j1 < m_A1; j1++)
            {
                C1.push_back(A1[j1]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int j2 = 0; j2 < m_A2; j2++)
            {
                C2.push_back(A2[j2]); // Запись всех элементов графика А в график С
            }

            for (int j = 0; j < m_A3; j++)
                if (A3[j].first == A1[0]  && count(C3.begin(), C3.end(), A3[j]) == 0)
                    C3.push_back(A3[j]);
        }
        else
        {
            // Цикл для записи графика А в график С
            for (int i1 = 0; i1 < m_B1; i1++)
            {
                C1.push_back(B1[i1]); // Запись всех элементов графика А в график С
            }

            // Цикл для записи графика А в график С
            for (int i2 = 0; i2 < m_B2; i2++)
            {
                C2.push_back(B2[i2]); // Запись всех элементов графика А в график С
            }

            for (int i = 0; i < m_B3; i++)
                if (B3[i].first == B1[0] && count(C3.begin(), C3.end(), B3[i]) == 0)
                    C3.push_back(B3[i]);
        }

        break;
    }

    case 10:
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) Образ А");
        printf("\n2) Образ B\n");
        printf("Выберите соответствие над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменну

        if (ord == 1)
        {
            for (int j = 0; j < m_A3; j++)
                if (A3[j].first == A1[0] && count(C.begin(), C.end(), A3[j].second) == 0)
                    C.push_back(A3[j].second);
        }
        else
        {
            for (int i = 0; i < m_B3; i++)
                if (B3[i].first == B1[0] && count(C.begin(), C.end(), B3[i].second) == 0)
                    C.push_back(B3[i].second);
        }

        break;
    }

    case 11:
    {
        // Вывод меню выбора и нструкции для пользователя
        printf("\n1) Прообраз А");
        printf("\n2) Прообраз B\n");
        printf("Выберите соответствие над которым будет происходить операция (1 или 2): ");
        scanf_s("%i", &ord); // Заносим ввод пользователя в переменну

        if (ord == 1)
        {
            for (int j = 0; j < m_A3; j++)
                if (A3[j].second == A2[0] && count(C.begin(), C.end(), A3[j].first) == 0)
                    C.push_back(A3[j].first);
        }
        else
        {
            for (int i = 0; i < m_B3; i++)
                if (B3[i].second == B2[0] && count(C.begin(), C.end(), B3[i].first) == 0)
                    C.push_back(B3[i].first);
        }

        break;
    }

    }

    }

    if (par1 != 10 && par1 != 11)
    {
        printf("\nСоответствие C: <{"); // Вывод пояснительного сообщения для пользователя

        for (int i = 0; i < C1.size(); i++)
        {
            if (i != C1.size() - 1)
                printf("%i%s", C1[i], ", ");
            else
                printf("%i", C1[i]);
        }

        printf("}, {");

        for (int i = 0; i < C2.size(); i++)
        {
            if (i != C2.size() - 1)
                printf("%i%s", C2[i], ", ");
            else
                printf("%i", C2[i]);
        }

        printf("}, {");

        // Цикл для вывода графика С
        for (int i = 0; i < C3.size(); i++)
        {
            if (C3[i].first != 0 && C3[i].second != 0)
                if (i != C3.size() - 1)
                    printf("%s%i%s%i%s", "<", C3[i].first, ", ", C3[i].second, ">, "); // Вывод элементов графика С
                else
                    printf("%s%i%s%i%s", "<", C3[i].first, ", ", C3[i].second, ">");
        }

        printf("}>\n"); // Вывод пояснительного сообщения для пользователя
    }
    else
    {
        printf("\nМножество C: {"); // Вывод пояснительного сообщения для пользователя

        for (int i = 0; i < C.size(); i++)
        {
            if (i != C.size() - 1)
                printf("%i%s", C[i], ", ");
            else
                printf("%i", C[i]);
        }

        printf("}\n");
    }

    system("pause"); // Остановка работы программы до тех пор пока пользователь не нажмёт любую клавишу
}
